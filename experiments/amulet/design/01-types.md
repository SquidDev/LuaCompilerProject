# Type system

Types in Amulet are composed of functions, tuples and primitives. You can store multiple types together in a tagged union (or sum type). A tagged union with one entry is a useful way of boxing a type to ensure that it cannot be accidentally used as an object of the same type but different semantics.

Types can also be generic over one or more parameters. When inferring the type for an expression, the most generic type will always be used. Constraints can be put on generic parameters by specifying type class implementations that must exist for this set of parameters. There can be multiple constraints, each applying to multiple parameters.

There is no subtyping in Amulet, *however* type constraints can be loosened through the upcast operator: this converts an existing value to a more general type: for instance `[a]` can be upcast to `Show b`.

## Record types

Record types are simple syntactic sugar for a product type. By defining a record type you create a product type and a series of methods (labeled fields) to extract a field from the record instance. Methods are also generated to "update" the record with a new value for a particular field.

## Tagged unions

Tagged unions, also known as *sum-of-product types*, are data structures that can take on several variations. Only one of these variants may be in use at once, and a tag field explicitly indicates so.

To extract data out of sum types, pattern matching is used.

Tagged unions can also contain record types, which normally would require a top level type definition.

> I’m not sure how to handle records in sum types, given that accessors and friends are methods ‘bound’ to the record. The logical solution would be ‘lifing’ them to the sum, but how do you ensure that it’s called on the right variant? And what when it isn’t? Return ⊥?

## Type classes

Type classes are a way to ensure different types have a consistent interface, and to constrain polymorphic types on having an instance of a type class.

A constraint section on a type is given as a fat-arrow behind the type. For example, the following snippet says that *for all types for which there is an instance of `a`, there is a function `show` transforming it into a string.*

```
show :: forall a. Show a => a -> String
```

The type-class mechanism poses a way to do name overloading based on types. In contrast to, say, Java interfaces, type classes allow the user to be parametric on the return type, not only the parameter types.

```
class Read a where
  read :: String -> a
```

When resolving type classes the type checking algorithm will unify the current type across all instances. If more than one instance matches then an error will be created.

Some type classes will be auto-generated by the compiler (such as `Eq` or `Show`) if the criteria are matched (for instance all child types also implement Show). Auto-generated instances can safely be overridden or masked: there will not be a compile error if both a auto-generated and normal instance match.

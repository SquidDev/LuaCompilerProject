--- Basic type parser
-- See doc/types/InternalRepresentation.md for full details

local function getMetainfo(node)
	local metainfo = node.metainfo
	if not metainfo then
		metainfo = {}
		node.metainfo = metainfo
	end
	return metainfo
end

local gg = require 'metalua.compiler.grammar.generator'

return function(M)
	local types = {}
	local _M = gg.future(M)
	local _types = gg.future(types)

	types.argument = gg.multisequence {
		name = "function argument definition",
		{"...", ":", _types.type, builder = |x| `Var { x[1] } },
		default = _types.type
	}

	types.returnDef = gg.multisequence {
		name = "function type return definition",
		gg.sequence {
			"[", gg.list {
				primary     = _types.argument,
				separators  = ",",
				terminators = "]"
			}, "]",
			builder = |x| `Tuple { unpack(x[1]) }
		},
		default = _types.type,
	}

	local functionSignature = gg.sequence {
		name = "function type definition",
		"(", gg.list {
			primary = _types.argument,
			separators  = ",",
			terminators = ")"
		}, ")", ":", _types.returnDef,
		builder = function(x)
			local val =  `FunctionType { unpack(x[1]) }
			table.insert(val, x[2])
			return val
		end
	}

	local tableSignature = gg.sequence {
		name = "table type definition",
		"{",
		_types.type,
		gg.onkeyword {
			'=', _types.type,
		},
		-- TODO: Object
		"}",
		builder = function(x)
			if x[2] then
				return `NamedType { "Map", x[1], x[2] }
			else
				return `NamedType { "Array", x[1] }
			end
		end
	}

	types.generic = gg.sequence {
		_M.id,
		gg.onkeyword {
			name = "generic type",
			"<",
			gg.sequence {
				gg.list {
					primary = _types.type,
					separators = ",",
					terminators = ">",
				},
				">",
			}
		},

		builder = function(x)
			if x[1][1] == "auto" and not x[2] then
				return `InferedType
			elseif x[2] then
				return `NamedType { x[1][1], unpack(x[2][1]) }
			else
				return `NamedType { x[1][1] }
			end
		end,
	}

	types.union = gg.sequence {
		_types.generic,
		gg.onkeyword {
			name = "union type",
			"|", _types.type,
		},
		builder = function(x)
			local a, b = x[1], x[2]
			if b then
				if b.tag == "Union" then
					return `Union { a, unpack(b) }
				else
					return `Union { a, b }
				end
			else
				return a
			end
		end,
	}

	types.type = gg.multisequence {
		name = "type",
		functionSignature,
		tableSignature,
		default = types.union,
	}

	-- Overrides
	M.declaration.default = gg.sequence {
		name = "declaration",
		_M.id, gg.onkeyword {
			name="type definition",
			":", _types.type
		},
		builder = function(node)
			-- If none specified then use `UnknownType
			getMetainfo(node[1]).type = node[2] or `UnknownType
			return node[1]
		end
	}

	M.func_val = gg.sequence {
		name = "function body",
		"(", _M.func_params_content, ")", gg.onkeyword {
			":", _types.returnDef
		},
		_M.block, "end",
		builder = function(x)
			local types = `FunctionType
			for _, params in ipairs(x[1]) do
				-- The `UnknownType either will infer or set to Any based on context
				table.insert(types, params.type or `UnknownType)
			end
			table.insert(types, x[2] or `UnknownType)

			return  `Function {
				x[1], x[3],
				metainfo = { type = types }
			}
		end
	}
end

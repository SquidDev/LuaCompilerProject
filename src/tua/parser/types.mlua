--- Basic type parser
-- See doc/types/InternalRepresentation.md for full details

-{extension("switch",...)}

local function getMetainfo(node)
	local metainfo = node.metainfo
	if not metainfo then
		metainfo = {}
		node.metainfo = metainfo
	end
	return metainfo
end

local gg = require 'metalua.compiler.grammar.generator'

return function(M)
	local types = {}
	local _M = gg.future(M)
	local _types = gg.future(types)
	M.lexer:add("->")

	types.argument = gg.multisequence {
		name = "function argument definition",
		{"...", ":", _types.type, builder = |x| `TVar { x[1] } },
		default = _types.type
	}

	local tuple_content = gg.list {
			primary     = _types.argument,
			separators  = ",",
			terminators = "]",
			builder = |x| `TTuple { unpack(x[1]) }
		}

	types.returnDef = gg.multisequence {
		name = "function type return definition",
		{"(", tuple_content, ")"},
		default = _types.type,
	}

	local functionSignature = gg.sequence {
		name = "function type definition",
		"(", tuple_content, ")", "->", _types.returnDef,
		builder = |x| `TFunction { x[1], x[2] }
	}

	local tableSignature = gg.sequence {
		name = "table type definition",
		"{",
		_types.type,
		gg.onkeyword {
			'=', _types.type,
		},
		-- TODO: Object
		"}",
		builder = function(x)
			if x[2] then
				return `NamedType { "Map", x[1], x[2] }
			else
				return `NamedType { "Array", x[1] }
			end
		end
	}

	types.base = gg.multisequence {
		{ "false", builder = |x| `TLiteral { true } },
		{ "true", builder = |x| `TLiteral { true } },
		default = { _M.id_or_literal, builder = function(x)
			switch x[1] do
				case `String { value }
				case `Number { value } then
					return `TLiteral { value }
				case `Id { name } then
					if name == "string" or name == "number" or name == "boolean" then
						return `TBase { name }
					else
						return `TNamed { name }
					end
			end
		end},
	}

	types.generic = gg.sequence {
		_M.id,
		gg.onkeyword {
			name = "generic type",
			"<",
			gg.sequence {
				gg.list {
					primary = _types.type,
					separators = ",",
					terminators = ">",
				},
				">",
			}
		},

		builder = function(x)
			if x[1][1] == "auto" and not x[2] then
				return `InferedType
			elseif x[2] then
				return `NamedType { x[1][1], unpack(x[2][1]) }
			else
				return `NamedType { x[1][1] }
			end
		end,
	}

	types.union = gg.sequence {
		_types.primary,
		gg.onkeyword {
			name = "union type",
			"|", _types.type,
		},
		builder = function(x)
			local a, b = x[1], x[2]
			if b then
				if b.tag == "Union" then
					return `Union { a, unpack(b) }
				else
					return `Union { a, b }
				end
			else
				return a
			end
		end,
	}

	types.primary = gg.multisequence {
		name = "type",
		functionSignature,
		tableSignature,
		default = types.generic,
	}

	types.type = gg.sequence {
		_types.union,
		gg.optkeyword { '?' },
		builder = function(x)
			if x[2] then return `TUnion { `TNil, x[1]} else return x[1] end
		end
	}

	-- Overrides
	M.declaration.default = gg.sequence {
		name = "declaration",
		_M.id, gg.onkeyword {
			name="type definition",
			":", _types.type
		},
		builder = function(node)
			-- If none specified then use `UnknownType
			getMetainfo(node[1]).type = node[2] or `UnknownType
			return node[1]
		end
	}

	M.func_val = gg.sequence {
		name = "function body",
		"(", _M.func_params_content, ")", gg.onkeyword {
			":", _types.returnDef
		},
		_M.block, "end",
		builder = function(x)
			local types = `FunctionType
			for _, params in ipairs(x[1]) do
				-- The `UnknownType either will infer or set to Any based on context
				table.insert(types, params.type or `UnknownType)
			end
			table.insert(types, x[2] or `UnknownType)

			return  `Function {
				x[1], x[3],
				metainfo = { type = types }
			}
		end
	}
end

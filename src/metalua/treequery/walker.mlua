--[[--
	Basic traversal library for nodes.
	 - traverse* methods handle a specific node category (node list, expression, ...)
	 - traverse*List methods ensure that the list passed is not a node
	 - visit* methods handle a specific node type (Dots, Function, ...)
	 - pushScope and popScope are called when entering and leaving scopes
	 - The main entry point is :traverse(node)
]]

-{ extension("switch", ...) }
-{ extension("class", ...) }

local pp = require 'metalua.pprint'

local function table_transpose(t)
	local tt = { }; for a, b in pairs(t) do tt[b]=a end; return tt
end

local class Walker
	--- Standard tags: can be used to guess the type of an AST, or to check
	-- that the type of an AST is respected.
	static tags = {
		stat = table_transpose {
			'Do', 'Set', 'While', 'Repeat', 'Local', 'Localrec', 'Return',
			'Fornum', 'Forin', 'If', 'Break', 'Goto', 'Label',
			'Call', 'Invoke'
		},
		expr = table_transpose {
			'Paren', 'Call', 'Invoke', 'Index', 'Op', 'Function', 'Stat',
			'Table', 'Nil', 'Dots', 'True', 'False', 'Number', 'String', 'Id'
		},
		declaration = table_transpose {
			'Local', 'Localrec', 'Forin', 'Fornum',
		}
	}

	static visitors = { }

	function new(child)
		self.child = child
	end

	--- Visit a statement - ensuring it is one
	function traverseStatement(node, ...)
		switch node do
		case { tag = tag, ...} if Walker.tags.stat[tag] then return self:traverse(node, ...)
		case _ then return self:unexpected(node, ...) or node
		end
	end

	--- Visit an expression - ensuring it is one
	function traverseExpression(node, ...)
		switch node do
		case { tag = tag, ...} if Walker.tags.expr[tag] then return self:traverse(node, ...)
		case _ then return self:unexpected(node, ...) or node
		end
	end

	function traverseDeclaration(node, ...)
		return self:traverse(node, ...)
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseBlock(list, ...)
		if list.tag then
			return self:malformed(list) or list
		else
			for i, y in ipairs(list) do
				list[i] = self:traverseStatement(y, list, ...)
			end
			return list
		end
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseExpressionList(list, ...)
		if list.tag then
			return self:malformed(list) or list
		else
			for i, y in ipairs(list) do
				list[i] = self:traverseExpression(y, list, ...)
			end
			return list
		end
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseDeclarationList(list, ...)
		if list.tag then
			return self:malformed(list) or list
		else
			for i, y in ipairs(list) do
				list[i] = self:traverseDeclaration(y, list, ...)
			end
			return list
		end
	end

	function pushScope() end
	function popScope() end

	--- Called on an unknown tag, or a tag not expected at that point
	function unknown(node, ...)
		self:error("Unknown node tag " .. (node.tag or '[nil]'), node)
	end

	--- Called on a tag not expected at that point
	function unexpected(node, ...)
		self:error("Unexpected node tag " .. (node.tag or '[nil]'), node)
	end

	--- Called on a malformed tag statement/expression list
	function malformed(node, ...)
		self:error("Unknown node of tag " .. (node.tag or '[nil]') .. ':' .. pp.tostring(node), node)
	end

	function error(message, node)
		error(message .. ' at ' .. tostring(node and node.lineinfo or '?'), 2)
	end

	function traverse(node, ...)
		if node == nil then
			self:error("Expected node, got nil", node, ...)
		elseif node.tag == nil then
			self:error("Expected node, got nil tag", node, ...)
		end

		local visitor = self['visit' .. node.tag] or Walker.visitors[node.tag]
		if visitor then
			return visitor(self, node, ...) or node
		else
			return self:unknown(node, ...) or node
		end
	end

	--- Main entry point
	function guess(node)
		if node == nil then
			self:error("Expected node, got nil", node)
		end
		if node.tag then
			return self:traverse(node)
		else
			return self:traverseBlock(node)
		end
	end

	function visitDo(node, ...)
		self:pushScope()
		for i, y in ipairs(node) do
			node[i] = self:traverseStatement(y, node, ...)
		end
		self:popScope()
	end

	function visitSet(node, ...)
		node[1] = self:traverseExpressionList(node[1], node, ...)
		node[2] = self:traverseExpressionList(node[2], node, ...)
	end

	function visitWhile(node, ...)
		local condition, body = unpack(node)
		node[1] = self:traverseExpression(condition, node, ...)
		self:pushScope()
		node[2] = self:traverseBlock(body, node, ...)
		self:popScope()
	end

	function visitRepeat(node, ...)
		local body, condition = unpack(node)
		self:pushScope()
		node[1] = self:traverseBlock(body, node, ...)
		node[2] = self:traverseExpression(condition, node, ...)
		self:popScope()
	end

	function visitLocal(node, ...)
		local lhs, rhs = unpack(node)
		if rhs then
			node[2] = self:traverseExpressionList(rhs, node, ...)
		end
		node[1] = self:traverseDeclarationList(lhs, node, ...)
	end

	function visitLocalrec(node, ...)
		local lhs, rhs = unpack(node)
		node[1] = self:traverseDeclarationList(lhs, node, ...)
		node[2] = self:traverseExpressionList(rhs, node, ...)
	end

	function visitFornum(node, ...)
		local i, a, b = unpack(node)
		node[2] = self:traverseExpression(a, node, ...)
		node[3] = self:traverseExpression(b, node, ...)

		switch node do
		case `Fornum{ _, _, _, body }  then
			self:pushScope()
			node[1] = self:traverseDeclarationList({i}, node, ...)
			node[4] = self:traverseBlock(body, node, ...)
			self:popScope()
		case `Fornum{ _, _, _, c, body } then
			node[4] = self:traverseExpression(c, node, ...)

			self:pushScope()
			node[1] = self:traverseDeclarationList({i}, node, ...)
			node[5] = self:traverseBlock(body, node, ...)
			self:popScope()
		end
	end

	function visitForin(node, ...)
		local i, rhs, body = unpack(node)
		node[2] = self:traverseExpression(rhs, node, ...)
		self:pushScope()
		node[1] = self:traverseDeclaration(i, node, ...)
		node[3] = self:traverseBlock(body, node, ...)
		self:popScope()
	end

	function visitIf(node, ...)
		for i = 1, #node - 1, 2 do
			node[i] = self:traverseExpression(node[i], node, ...)
			self:pushScope()
			node[i + 1] = self:traverseBlock(node[i + 1], node, ...)
			self:popScope()
		end

		if #node % 2 == 1 then
			self:pushScope()
			node[#node] = self:traverseBlock(node[#node], node, ...)
			self:popScope()
		end
	end

	function visitCall(node,...)
		for i, y in ipairs(node) do
			node[i] = self:traverseExpression(y, node, ...)
		end
	end

	function visitInvoke(node, ...)
		return self:traverseCall(node, ...)
	end

	function visitReturn(node, ...)
		for i, y in ipairs(node) do
			node[i] = self:traverseExpression(y, node, ...)
		end
	end

	function visitBreak() end
	function visitGoto() end
	function visitLabel() end

	function visitParen(node, ...)
		node[1] = self:traverseExpression(node[1], node, ...)
	end

	function visitIndex(node, ...)
		node[1] = self:traverseExpression(node[1], node, ...)
		node[2] = self:traverseExpression(node[2], node, ...)
	end

	function visitOp(node, ...)
		node[2] = self:traverseExpression(node[2], node, ...)
		if #node == 3 then
			node[3] = self:traverseExpression(node[3], node, ...)
		end
	end

	function visitFunction(node, ...)
		self:pushScope()
		node[1] = self:traverseDeclarationList(node[1], node, ...)
		node[2] = self:traverseBlock(node[2], node, ...)
		self:popScope()
	end

	function visitStat(node, ...)
		self:pushScope()
		node[1] = self:traverseBlock(node[1], node, ...)
		node[2] = self:traverseExpression(node[2], node, ...)
		self:popScope()
	end

	function visitTable(node, ...)
		for i, item in ipairs(node) do
			switch item do
			case `Pair { k, v } then
				item[1] = self:traverseExpression(k)
				item[2] = self:traverseExpression(v)
			case v then node[i] = self:traverseExpression(v)
			end
		end
	end

	function visitId() end
	function visitNil() end
	function visitDots() end
	function visitTrue() end
	function visitFalse() end
	function visitNumber() end
	function visitString() end

	static function addNode(name, visitor, types)
		Walker.visitors[name] = visitor or ||nil
		if type(types) == "string" then types = {types} end
		for _, v in ipairs(types) do
			Walker.tags[v][name] = true
		end
	end
end

return Walker

--- Adds an 'export' command to export variables
-- `export a = "HELLO"` results in `local a = "HELLO", return {a  = a}`
-- `export function a() end` results in local function a() end return {a = a}`

-{ extension ("switch", ...) }
-{ extension ("class", ...) }

local gg = require 'metalua.compiler.grammar.generator'
local Walker = require 'metalua.treequery.walker'

local class ExportWalker extends Walker
	returns = {}

	function visitExport(node, parent, ...)
		Walker.prototype.visitExport(self, node, parent, ...)

		if parent and parent.tag and parent.tag ~= "Function" then
			self:fatal("Cannot export from non-function " .. parent.tag, node)
		else
			local returns = self.returns[#self.returns]
			for _, e in ipairs(node[1][1]) do
				table.insert(returns, `Pair { `String { e[1]}, e})
			end
		end

		return node[1]
	end

	function traverseBlock(node, parent, ...)
		local returns = `Table {}
		if not parent or parent.tag == "Function" then
			table.insert(self.returns, returns)
		end

		Walker.prototype.traverseBlock(self, node, parent, ...)
		if not parent or parent.tag == "Function" then
			self.returns[#self.returns] = nil

			if #returns > 0 then
				switch node[#node] do
					case `Return { ... } then self:fatal("Cannot return as this method exports", node[#node])
					case _ then
				end

				local ret = `Return { returns }
				self:traverse(ret, node, parent, ...)
				table.insert(node, ret)
			end
		end

		return node
	end
end

Walker.addNode("Export", function(self, node, ...)
	self:traverseStatement(node[1], node, ...)
	return node
end, {"stat", "declaration"})

return function(mlp)
	mlp.chunk.transformers:add(function(x)
		local r = ExportWalker():guess(x)
		print("After: " .. require'metalua.pprint'.tostring(r, {hide_hash = true}))
		return r
	end)

	-- Pluging the parsers in the syntax
	mlp.lexer:add { "export" }

	mlp.stat:add {
		name = "export",
		"export", mlp.local_stat_parser,
		builder = "Export",
	}
end

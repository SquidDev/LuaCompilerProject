--- Adds basic classes
-- Syntax:
-- ```
-- class <name> (extends ...)? has
-- 	local field  ="foo"
-- 	function name()
-- 		return self
-- 	end
-- end
-- ```

-{ extension ("switch", ...) }

local gg  = require 'metalua.compiler.grammar.generator'

local call = +{ function(s, ...) local o = setmetatable({}, { __index = s.prototype}) o:new(...) return o end }

return function(M)
	local _M = gg.future(M)

	local function classBuilder(x)
		local ancestors, decl = x[1] or `Table{ }, x[2]
		ancestors.tag = "Table"

		local prototypeName = gg.gensym("class")
		-- Prototype stores the methods, the meta provides a lookup for the parent
		local prototype, protoMeta = `Table{ }, `Table { }

		-- Class stores static methods, class meta provides the constructor
		local class, classMeta = `Table { }, ` Table { }

		table.insert(classMeta, `Pair { `String "__call", call })
		table.insert(class, `Pair { `String "prototype", prototypeName })

		switch #ancestors do
			case 0 then
			case 1 then
				local parent = `Index { ancestors[1], `String { "prototype" } }
				table.insert(protoMeta, `Pair { `String "__index", parent })
				table.insert(prototype, `Pair { `String "super", parent })
			case n then error "This class model doesn't support multiple inheritance"
		end

		local constructor = {}
		local actualConstructor = nil
		for _, member in ipairs(decl) do
			switch member do
			case `StaticMember { child } then
				switch child do
				case `Local { lhs, rhs }
				case `Localrec {lhs, rhs } then
					for i = 1, #lhs do
						if rhs[i] ~= nil then
							table.insert(class, `Pair{ M.id2string(lhs[i]), rhs[i]})
						end
					end
				end
			case `Member { child} then
				switch child do
				case `Local { lhs, rhs }
				case `Localrec {lhs, rhs } then
					for i = 1, #lhs do
						local right = rhs[i]
						if right ~= nil then
							switch right do
							case `Function { _, _ } then
								table.insert(right[1], 1, `Id { "self" })
								if lhs[i][1] == "new" then
									actualConstructor = right
								else
									table.insert(prototype, `Pair{ M.id2string(lhs[i]), right})
								end
							case _ then
								table.insert(constructor, `Set {
									{ `Index { `Id { "self" }, M.id2string(lhs[i]) } } , { right }
								})
							end
						end
					end
				end
			end
		end

		if not actualConstructor then
			actualConstructor = `Function { { `Id {"self"} }, { } }

			if #ancestors == 1 then
				table.insert(actualConstructor[2], `Call {
					`Index { `Index { ancestors[1] , `String { "prototype"} }, `String { "new"}  },
					`Id { "self" }
				})
			end
		end

		local constructorBody = actualConstructor[2]
		for i, stat in ipairs(constructor) do
			table.insert(constructorBody, i, stat)
			if i > 100 then error("Whoah") end
		end
		table.insert(prototype, `Pair{ `String { "new"}, actualConstructor})


		if #protoMeta > 0 then
			prototype = `Call{ `Id "setmetatable", prototype, protoMeta }
		end

		return {
			`Local { { prototypeName}, { prototype } },
			`Call{ `Id "setmetatable", class, classMeta }
		}
	end

	--------------------------------------------------------------------------------
	-- Parsers
	--------------------------------------------------------------------------------
	local ancestry = gg.onkeyword {
		name="class ancestors",
		"extends", gg.list{ _M.expr, separators="," }
	}

	local memberParser = gg.sequence {
		name="in-class method definition",
		_M.local_stat_parser,
		builder = 'Member',
	}

	local staticMemberParser = gg.sequence {
		name="in-class method definition",
		"static", _M.local_stat_parser,
		builder = 'StaticMember',
	}

	local classBody = gg.sequence {
		name = "class body",
		ancestry,
		gg.list {
			gg.multisequence { memberParser, staticMemberParser },
			terminators="end"
		},
		"end",
		builder = classBuilder
	}

	--------------------------------------------------------------------------------
	-- Pluging the parsers in the syntax
	--------------------------------------------------------------------------------
	M.lexer:add { "class", "extends", "static" }

	M.stat:add {
		name = "class declaration",
		"class", _M.id, classBody,
		builder = |x| {
			-- Class -> Local
			x[2][1],
			-- Id, Class -> Call
			`Set{ {x[1]}, {x[2][2] }}
		}
	}

	M.local_stat_parser:add {
		name = "class declaration",
		"class", _M.id, classBody,
		builder = |x| {
			`Local{ {x[1]} },
			-- Class -> Local
			x[2][1],
			-- Id, Class -> Call
			`Set{ {x[1]}, {x[2][2] }}
		}
	}
end

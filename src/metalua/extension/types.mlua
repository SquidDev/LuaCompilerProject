--- Allows to write "a `f` b" instead of "f(a, b)". Taken from Haskell.

local gg = require 'metalua.compiler.grammar.generator'

return function(M)
	local types = {}
	local _M = gg.future(M)
	local _types = gg.future(types)

	local function getMetainfo(node)
		local metainfo = node.metainfo
		if not metainfo then
			metainfo = {}
			node.metainfo = metainfo
		end
		return metainfo
	end

	local returnDef = gg.multisequence {
		{
			"[", gg.list {
				primary     = _types.type_def,
				separators  = ",",
				terminators = "]"
			}, "]"
		},
		default = _types.type_def,
	}

	local functionSignature = gg.sequence {
		name = "function type definition",
		"(", gg.list {
			primary     = _types.type_def,
			separators  = ",",
			terminators = ")"
		}, ")", ":", returnDef,
		builder = function(x)
			return `FunctionType { unpack(x) }
		end
	}

	local tableSignature = gg.sequence {
		name = "table type definition",
		"{",
		_types.type_def,
		gg.onkeyword {
			'=', _types.type_def,
		},
		-- TODO: Interface
		"}",
		builder = function(x)
			if x[2] then
				return `HashType { x[1], x[2] }
			else
				return `ArrayType { x[1] }
			end
		end
	}

	types.type_def = gg.multisequence {
		name = "type",
		functionSignature,
		tableSignature,
		default = function(lx) return `BasicType { _M.id(lx)[1] } end,
	}

	-- Overrides
	M.declaration.default = gg.sequence {
		name = "declaration",
		_M.id, gg.onkeyword {
			name="type definition",
			":", _types.type_def
		},
		builder = function(node)
			-- If we specify unknown then we probably will replace it
			-- with `Any. However it may be that we do want to imply it
			getMetainfo(node[1]).type = node[2] or `Unknown
			return node[1]
		end
	}

	M.func_val = gg.sequence {
		name = "function body",
		"(", _M.func_params_content, ")", gg.onkeyword {
			":", returnDef
		},
		_M.block, "end",
		builder = function(x)
			local types = `FunctionType { }
			for _, params in ipairs(x[1]) do
				table.insert(types, params.type or `Unknown)
			end
			table.insert(types, x[2] or `Unknown)

			return  `Function {
				x[1], x[3],
				metainfo = { type = types }
			}
		end
	}
end

-------------------------------------------------------------------------------
-- Copyright (c) 2006-2013 Fabien Fleutot and others.
--
-- All rights reserved.
--
-- This program and the accompanying materials are made available
-- under the terms of the Eclipse Public License v1.0 which
-- accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- This program and the accompanying materials are also made available
-- under the terms of the MIT public license which accompanies this
-- distribution, and is available at http://www.lua.org/license.html
--
-- Contributors:
--	 Fabien Fleutot - API and implementation
--
-------------------------------------------------------------------------------
--
-- This extension implements list comprehensions, similar to Haskell and
-- Python syntax, to easily describe lists.
--
-- * x[a ... b] is the list { x[a], x[a+1], ..., x[b] }
-- * { f()..., b } contains all the elements returned by f(), then b
--	(allows to expand list fields other than the last one)
-- * list comprehensions a la python, with "for" and "if" suffixes:
--	{i+10*j for i=1,3 for j=1,3 if i~=j} is { 21, 31, 12, 32, 13, 23 }
--
-------------------------------------------------------------------------------

-{ extension ("switch", ...) }

local gg  = require 'metalua.compiler.grammar.generator'

local function dots_list_suffix_builder (x) return `DotsSuffix{ x } end

local function for_list_suffix_builder (list_element, suffix)
	local new_header = suffix[1]
	switch list_element do
		case `Comp{ _, acc } then table.insert (acc, new_header); return list_element
		case  _ then return `Comp{ list_element, { new_header } }
	end
end

local function if_list_suffix_builder (list_element, suffix)
	local new_header = `If{ suffix[1] }
	switch list_element do
		case `Comp{ _, acc } then table.insert (acc, new_header); return list_element
		case  _ then return `Comp{ list_element, { new_header } }
	end
end

--- Builds a statement from a table element, which adds this element to
-- a table `t`, potentially thanks to an alias `tinsert` to
-- `table.insert`.
-- @param core the part around which the loops are built.
--	either `DotsSuffix{expr}, `Pair{ expr } or a plain expression
-- @param list comprehension suffixes, in the order in which they appear
--	either `Forin{ ... } or `Fornum{ ...} or `If{ ... }. In each case,
--	it misses a last child node as its body.
-- @param t a variable containing the table to fill
-- @param tinsert a variable containing `table.insert`.
--
-- @return fill a statement which fills empty table `t` with the denoted element
local function comp_list_builder(core, list, t, tinsert)
	local filler
	-- 1 - Build the loop's core: if it has suffix "...", every elements of the
	-- multi-return must be inserted, hence the extra [for] loop.
	switch core do
		case `DotsSuffix{ element } then
			local x = gg.gensym("dots_index")
			filler = +{stat: for _, -{x} in pairs{ -{element} } do (-{tinsert})(-{t}, -{x}) end }
		case `Pair{ key, value } then
			--filler = +{ -{t}[-{key}] = -{value} }
			filler = `Set{ { `Index{ t, key } }, { value } }
		case _ then filler = +{ (-{tinsert})(-{t}, (-{core})) }
	end

	-- 2 - Stack the `if` and `for` control structures, from outside to inside.
	--	 This is done in a destructive way for the elements of [list].
	for i = #list, 1, -1 do
		table.insert (list[i], {filler})
		filler = list[i]
	end

	return filler
end

local function table_content_builder (list)
	local special = false -- Does the table need a special builder?
	for _, element in ipairs(list) do
		local etag = element.tag
		if etag=='Comp' or etag=='DotsSuffix' then special=true; break end
	end
	if not special then list.tag='Table'; return list end

	local t, tinsert = gg.gensym 'table', gg.gensym 'table_insert'
	local filler_block = { +{stat: local -{t}, -{tinsert} = { }, table.insert } }

	local last = #list
	for index, element in ipairs(list) do
		local filler
		switch element do
			case `Comp{ core, comp } then filler = comp_list_builder(core, comp, t, tinsert)
			case `Call { ... } if index == last then filler = comp_list_builder(`DotsSuffix { element }, { }, t, tinsert)
			case _ then filler = comp_list_builder(element, { }, t, tinsert)
		end
		table.insert(filler_block, filler)
	end
	return `Stat{ filler_block, t }
end

-- Improved "[...]" index operator:
--  * support for multi-indexes ("foo[bar, gnat]")
--  * support for ranges ("foo[bar ... gnat]")
--------------------------------------------------------------------------------
-- Back-end for improved index operator.
local function index_builder(a, suffix)
	switch suffix[1] do
		-- Single index, no range: keep the native semantics
		case { { e, false } } then return `Index{ a, e }
		-- Either a range, or multiple indexes, or both
		case ranges then
			local t, tinsert, toriginal = gg.gensym 'table', gg.gensym 'table_insert', gg.gensym 'table_original'
			local start, finish = gg.gensym 'start', gg.gensym 'finish'

			local filler_block = { +{stat: local -{t}, -{tinsert}, -{toriginal}, -{start}, -{finish} = { }, table.insert, -{a} } }
			for _, seq in ipairs (ranges) do
				switch seq do
					case { e, false } then table.insert(filler_block, `Call { tinsert, t, `Index { toriginal, e} })
					case { e, f } then
						table.insert(filler_block, `Set {
							{ start, finish },
							{  e, f }
						})
						table.insert(filler_block, +{stat:
							for i= -{start}, -{finish}, -{start} <= -{finish} and 1 or -1 do (-{tinsert})(-{t}, -{toriginal}[i]) end
						})
				end
				table.insert(filler_block, filler)
			end
			return `Stat { filler_block, t }
	end
end

return function(M)
	local _M = gg.future(M)

	-- support for "for" / "if" comprehension suffixes in literal tables
	local original_table_element = M.table.element
	M.table.element = gg.expr{ name="table cell",
		primary = original_table_element,
		suffix  = { name="table cell suffix",
			{ "...",                builder = dots_list_suffix_builder },
			{ "for", _M.for_header, builder = for_list_suffix_builder  },
			{ "if",  _M.expr,       builder = if_list_suffix_builder   }
		}
	}
	M.table.content.builder = table_content_builder

	-- Support for ranges and multiple indices in bracket suffixes
	M.expr.suffix:del '['
	M.expr.suffix:add { name="table index/range",
		"[", gg.list{
			gg.sequence { _M.expr, gg.onkeyword{ "...", _M.expr } },
			separators = { ",", ";" }
		}, "]", builder = index_builder }
end

--[[--
	Basic traversal library for nodes.
	 - traverse* methods handle a specific node category (node list, expression, ...)
	 - traverse*List methods ensure that the list passed is not a node
	 - visit* methods handle a specific node type (Dots, Function, ...)
	 - pushScope and popScope are called when entering and leaving scopes
	 - The main entry point is :visit(node)
]]

-{ extension("switch", ...) }
-{ extension("class", ...) }

local pp = require 'metalua.pprint'

local function table_transpose(t)
	local tt = { }; for a, b in pairs(t) do tt[b]=a end; return tt
end

local class Walker
	--- Standard tags: can be used to guess the type of an AST, or to check
	-- that the type of an AST is respected.
	static tags = {
		stat = table_transpose{
			'Do', 'Set', 'While', 'Repeat', 'Local', 'Localrec', 'Return',
			'Fornum', 'Forin', 'If', 'Break', 'Goto', 'Label',
			'Call', 'Invoke'
		},
		expr = table_transpose{
			'Paren', 'Call', 'Invoke', 'Index', 'Op', 'Function', 'Stat',
			'Table', 'Nil', 'Dots', 'True', 'False', 'Number', 'String', 'Id'
		}
	}

	static visitors = { }

	function new(child)
		self.child = child
	end

	--- Visit a statement - ensuring it is one
	function traverseStatement(node, ...)
		switch node do
		case { tag = tag, ...} if Walker.tags.stat[tag] then self:visit(node, ...)
		case _ then self:unexpected(node, ...)
		end
	end

	--- Visit an expression - ensuring it is one
	function traverseExpression(node, ...)
		switch node do
		case { tag = tag, ...} if Walker.tags.expr[tag] then self:visit(node, ...)
		case _ then self:unexpected(node, ...)
		end
	end

	function traverseDeclaration(node, ...)
		self:visit(node, ...)
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseBlock(list, ...)
		if list.tag then
			self:malformed(list)
		else
			for _, y in ipairs(list) do
				self:traverseStatement(y, list, ...)
			end
		end
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseExpressionList(list, ...)
		if list.tag then
			self:malformed(list)
		else
			for _, y in ipairs(list) do
				self:traverseExpression(y, list, ...)
			end
		end
	end

	--- Visit a statement list - ensuring it is not a node
	function traverseDeclarationList(list, ...)
		if list.tag then
			self:malformed(list)
		else
			for _, y in ipairs(list) do
				self:traverseDeclaration(y, list, ...)
			end
		end
	end

	function pushScope() end
	function popScope() end

	--- Called on an unknown tag, or a tag not expected at that point
	function unknown(node, ...)
		self:error("Unknown node tag " .. (node.tag or '[nil]'), node)
	end

	--- Called on a tag not expected at that point
	function unexpected(node, ...)
		self:error("Unexpected node tag " .. (node.tag or '[nil]'), node)
	end

	--- Called on a malformed tag statement/expression list
	function malformed(node, ...)
		self:error("Unknown node of tag " .. (node.tag or '[nil]') .. ':' .. pp.tostring(node), node)
	end

	function error(message, node)
		error(message .. ' at ' .. tostring(node and node.lineinfo or '?'), 2)
	end

	function visit(node, ...)
		if node == nil then
			self:error("Expected node, got nil", node, ...)
		elseif node.tag == nil then
			self:error("Expected node, got nil tag", node, ...)
		end
		local visitor = self['visit' .. node.tag] or Walker.visitors[node.tag]
		if visitor then
			visitor(self, node, ...)
			if self.child then
				self.child:visit(node, ...)
			end
		else
			self:unknown(node, ...)
		end
	end

	--- Main entry point
	function guess(node)
		if node == nil then
			self:error("Expected node, got nil", node)
		end
		if node.tag then
			self:visit(node)
		else
			self:traverseBlock(node)
		end
	end

	function visitDo(node, ...)
		self:pushScope()
		for _, y in ipairs(node) do
			self:traverseStatement(y, node, ...)
		end
		self:popScope()
	end

	function visitSet(node, ...)
		local lhs, rhs = unpack(node)
		self:traverseExpressionList(lhs, node, ...)
		self:traverseExpressionList(rhs, node, ...)
	end

	function visitWhile(node, ...)
		local condition, body = unpack(node)
		self:traverseExpression(condition, node, ...)
		self:pushScope()
		self:traverseBlock(body, node, ...)
		self:popScope()
	end

	function visitRepeat(node, ...)
		local body, condition = unpack(node)
		self:pushScope()
		self:traverseBlock(body, node, ...)
		self:traverseExpression(condition, node, ...)
		self:popScope()
	end

	function visitLocal(node, ...)
		local lhs, rhs = unpack(node)
		if rhs then
			self:traverseExpressionList(rhs, node, ...)
		end
		self:traverseDeclarationList(lhs, node, ...)
	end

	function visitLocalrec(node, ...)
		local lhs, rhs = unpack(node)
		self:traverseDeclarationList(lhs, node, ...)
		self:traverseExpressionList(rhs, node, ...)
	end

	function visitFornum(node, ...)
		local i, a, b = unpack(node)
		self:traverseExpression(a, node, ...)
		self:traverseExpression(b, node, ...)

		local body
		switch node do
		case `Fornum{ _, _, _, bod }  then body = bod
		case `Fornum{ _, _, _, c, bod } then self:traverseExpression(c, node, ...) body = bod
		end

		self:pushScope()
		self:traverseDeclarationList({i}, node, ...)
		self:visitBlock(body, node, ...)
		self:popScope()
	end

	function visitForin(node, ...)
		local i, rhs, body = unpack(node)
		self:traverseExpression(rhs, node, ...)
		self:pushScope()
		self:traverseDeclaration(i, node, ...)
		self:traverseBlock(body, node, ...)
		self:popScope()
	end

	function visitIf(node, ...)
		for i = 1, #node - 1, 2 do
			self:traverseExpression(node[i], node, ...)
			self:pushScope()
			self:traverseBlock(node[i + 1], node, ...)
			self:popScope()
		end

		if #node % 2 == 1 then
			self:pushScope()
			self:traverseBlock(node[#node], node, ...)
			self:popScope()
		end
	end

	function visitCall(node,...)
		for _, y in ipairs(node) do
			self:traverseExpression(y, node, ...)
		end
	end

	function visitInvoke(node, ...)
		self:visitCall(node, ...)
	end

	function visitReturn(node, ...)
		for _, y in ipairs(node) do
			self:traverseExpression(y, node, ...)
		end
	end

	function visitBreak() end
	function visitGoto() end
	function visitLabel() end

	function visitParen(node, ...)
		self:visitExpression(node[1], node, ...)
	end

	function visitIndex(node, ...)
		self:traverseExpression(node[1], node, ...)
		self:traverseExpression(node[2], node, ...)
	end

	function visitOp(node, ...)
		self:traverseExpression(node[2], node, ...)
		if #node == 3 then
			self:traverseExpression(node[3], node, ...)
		end
	end

	function visitFunction(node, ...)
		self:pushScope()
		self:traverseDeclarationList(node[1], node, ...)
		self:traverseBlock(node[2], node, ...)
		self:popScope()
	end

	function visitStat(node, ...)
		self:pushScope()
		self:traverseBlock(node[1], node, ...)
		self:traverseExpression(node[2], node, ...)
		self:popScope()
	end

	function visitTable(node, ...)
		for _, item in ipairs(node) do
			switch item do
			case `Pair { k, v } then
				self:traverseExpression(k)
				self:traverseExpression(v)
			case v then self:traverseExpression(v)
			end
		end
	end

	function visitId() end
	function visitNil() end
	function visitDots() end
	function visitTrue() end
	function visitFalse() end
	function visitNumber() end
	function visitString() end

	static function addNode(name, visitor, type)
		Walker.visitors[name] = visitor or ||nil
		if type == "expr" or type == "both" then Walker.tags.expr[name] = true end
		if type == "stat" or type == "both" then Walker.tags.stat[name] = true end
	end
end

return Walker

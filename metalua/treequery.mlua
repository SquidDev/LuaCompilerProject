-------------------------------------------------------------------------------
-- Copyright (c) 2006-2013 Fabien Fleutot and others.
--
-- All rights reserved.
--
-- This program and the accompanying materials are made available
-- under the terms of the Eclipse Public License v1.0 which
-- accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- This program and the accompanying materials are also made available
-- under the terms of the MIT public license which accompanies this
-- distribution, and is available at http://www.lua.org/license.html
--
-- Contributors:
--	 Fabien Fleutot - API and implementation
--
-------------------------------------------------------------------------------
-{extension("opequals", ...)}
-{extension("class", ...)}

local Walker = require 'metalua.treequery.walker'

--- multimap helper mmap: associate a key to a set of values
local function mmap_add (mmap, node, x)
	if node == nil then return end
	local set = mmap[node]
	if set then set[x] = true
	else mmap[node] = {[x]=true} end
end

local class TreeQueryWalker extends Walker
	function new(query, up, down)
		self.query = query
		self.until_up = { }
		self.from_up  = { }
		self.up_f = up
		self.down_f = down
	end

	function traverse(...)
		local query = self.query
		local satisfied = query.unsatisfied == 0
		for _, x in ipairs(query.predicates) do
			if not x.satisfied and x.pred(...) then
				x.satisfied = true
				local node, parent = ...
				local inc = x.inverted and 1 or -1
				if x.position == 'under' then
					-- satisfied from after we get down this node...
					query.unsatisfied += inc
					-- ...until before we get up this node
					mmap_add(self.until_up, node, x)
				elseif x.position == 'after' then
					-- satisfied from after we get up this node...
					mmap_add(self.from_up, node, x)
					-- ...until before we get up this node's parent
					mmap_add(self.until_up, parent, x)
				elseif x.position=='under_or_after' then
					-- satisfied from after we get down this node...
					query.satisfied += inc
					-- ...until before we get up this node's parent...
					mmap_add(self.until_up, parent, x)
				else
					error "position not understood"
				end -- position
				if x.inclusive then satisfied = query.unsatisfied==0 end
			end -- predicate passed
		end -- for predicates

		if satisfied then
			for _, f in ipairs(query.filters) do
				if not f(...) then
					satisfied = false
					break
				end
			end
			if satisfied and self.down_f then self.down_f(...) end
		end

		self.super.traverse(self, ...)

		-- Remove predicates which are due before we go up this node
		local preds = self.until_up[...]
		if preds then
			for x, _ in pairs(preds) do
				local inc = x.inverted and -1 or 1
				query.unsatisfied += inc
				x.satisfied = false
			end
			self.until_up[...] = nil
		end

		-- Execute the up callback
		-- TODO: cache the filter passing result from the down callback
		-- TODO: skip if there's no callback
		satisfied = query.unsatisfied == 0 and satisfied
		if satisfied and self.up_f then
			self.up_f(...)
		end

		-- Set predicate which are due after we go up this node
		local preds = self.from_up[...]
		if preds then
			for p, _ in pairs(preds) do
				local inc = p.inverted and 1 or -1
				query.unsatisfied += inc
			end
			self.from_up[...] = nil
		end
	end

	function unknown(...)
		local unknown = self.query.unknown_handler
		if unknown then
			unknown(...)
		else
			self.super.unknown(self, ...)
		end
	end
end

local class TreeQuery
	--- Treequery constructor
	--  the resulting object will allow to filter and operate on the AST
	--  @param root the AST to visit
	function new(root)
		self.root = root
		self.unsatisfied = 0
		self.predicates = { }
		self.up_f  = false
		self.down_f = false
		self.filters = { }

		self.unknown_handler = nil
	end

	function if_unknown(f)
		self.unknown_handler = f or (||nil)
		return self
	end

	--- helper to share the implementations of positional filters
	function add_pos_filter(position, inverted, inclusive, f, ...)
		if type(f) == 'string' then f = self:has_tag(f, ...) end
		if not inverted then self.unsatisfied += 1 end
		table.insert(self.predicates, {
			pred      = f,
			position  = position,
			satisfied = false,
			inverted  = inverted  or false,
			inclusive = inclusive or false
		})
		return self
	end

	--- select nodes which are after one which satisfies predicate f
	function after(f, ...)
		return self:add_pos_filter('after', false, false, f, ...)
	end

	--- select nodes which are not after one which satisfies predicate f
	function not_after(f, ...)
		return self:add_pos_filter('after', true, false, f, ...)
	end

	--- select nodes which are under one which satisfies predicate f
	function under(f, ...)
		return self:add_pos_filter('under', false, false, f, ...)
	end

	--- select nodes which are not under one which satisfies predicate f
	function not_under(f, ...)
		return self:add_pos_filter('under', true, false, f, ...)
	end

	--- select nodes which satisfy predicate f
	function filter(f, ...)
		if type(f) == 'string' then f = self:has_tag(f, ...) end
		table.insert(self.filters, f)
		return self
	end

	--- select nodes which do not satisfy predicate f
	function filter_not(f, ...)
		if type(f) == 'string' then f = M.has_tag(f, ...) end
		table.insert(self.filters, |...| not f(...))
		return self
	end

	--- Execute a function on each selected node
	--  @tparam function down function executed when we go down a node, (before its children have been examined).
	--  @tparam function up executed when we go up a node, (after its children have been examined).
	function foreach(down, up)
		if not up and not down then
			error "iterator missing"
		end
		self:execute(up, down)
	end

	--- Return the list of nodes selected by a given treequery.
	function list()
		local acc = { }
		self:foreach(|x| table.insert(acc, x))
		return acc
	end

	--- Return the first matching element
	--  TODO:  dirty hack, to implement properly with a 'break' return.
	--  Also, it won't behave correctly if a predicate causes an error,
	--  or if coroutines are involved.
	function first()
		local result = { }
		local function f(...) result = {...}; error() end
		pcall(|| self:foreach(f))
		return unpack(result)
	end

	--- Return a predicate which is true if the tested node's tag is among the
	--  one listed as arguments
	-- @param ... a sequence of tag names
	function has_tag(...)
		local args = {...}
		if #args==1 then
			local tag = ...
			return (|node| node.tag==tag)
		else
			local tags = { }
			for _, tag in ipairs(args) do tags[tag]=true end
			return function(node)
				local node_tag = node.tag
				return node_tag and tags[node_tag]
			end
		end
	end

	--- private helper: apply filters and execute up/down callbacks when applicable
	function execute(up, down)
		TreeQueryWalker(self, up, down):guess(self.root)
	end
end

return TreeQuery

--- Adds basic classes
-- Syntax:
-- ```
-- class <name> (extends ...)? has
-- 	local field  ="foo"
-- 	function name()
-- 		return self
-- 	end
-- end
-- ```

-{ extension ("match", ...) }

local gg  = require 'metalua.compiler.grammar.generator'

local call = +{ function(s, ...) local o = setmetatable({}, { __index = s.prototype}) o:new(...) return o end }

return function(M)
	local _M = gg.future(M)

	local function classBuilder(x)
		local ancestors, decl = x[1] or `Table{ }, x[2]
		ancestors.tag = "Table"

		local prototypeName = gg.gensym("class")
		-- Prototype stores the methods, the meta provides a lookup for the parent
		local prototype, protoMeta = `Table{ }, `Table { }

		-- Class stores static methods, class meta provides the constructor
		local class, classMeta = `Table { }, ` Table { }

		table.insert(classMeta, `Pair { `String "__call", call })
		table.insert(class, `Pair { `String "prototype", prototypeName })

		match #ancestors with
			| 0 ->
			| 1 ->
				local parent = `Index { ancestors[1], `String { "prototype" } }
				table.insert(protoMeta, `Pair { `String "__index", parent })
				table.insert(prototype, `Pair { `String "super", parent })
			| n -> error "This class model doesn't support multiple inheritance"
		end

		local constructor = {}
		local actualConstructor = nil
		for _, member in ipairs(decl) do
			match member with
			| `StaticMember { child } ->
				match child with
				| `Local { lhs, rhs }
				| `Localrec {lhs, rhs } ->
					for i = 1, #lhs do
						if rhs[i] ~= nil then
							table.insert(class, `Pair{ M.id2string(lhs[i]), rhs[i]})
						end
					end
				end
			| `Member { child} ->
				match child with
				| `Local { lhs, rhs }
				| `Localrec {lhs, rhs } ->
					for i = 1, #lhs do
						local right = rhs[i]
						if right ~= nil then
							match right with
							| `Function { _, _ } ->
								table.insert(right[1], 1, `Id { "self" })
								if lhs[i][1] == "new" then
									actualConstructor = right
								else
									table.insert(prototype, `Pair{ M.id2string(lhs[i]), right})
								end
							| _ ->
								table.insert(constructor, `Set {
									{ `Index { `Id { "self" }, M.id2string(lhs[i]) } } , { right }
								})
							end
						end
					end
				end
			end
		end

		if not actualConstructor then
			actualConstructor = `Function { { `Id {"self"} }, { } }
		end

		local constructorBody = actualConstructor[2]
		for i, stat in ipairs(constructor) do
			table.insert(constructorBody, i, stat)
			if i > 100 then error("Whoah") end
		end
		table.insert(prototype, `Pair{ `String { "new"}, actualConstructor})


		if #protoMeta > 0 then
			prototype = `Call{ `Id "setmetatable", prototype, protoMeta }
		end

		return {
			`Local { { prototypeName}, { prototype } },
			`Call{ `Id "setmetatable", class, classMeta }
		}
	end

	--------------------------------------------------------------------------------
	-- Parsers
	--------------------------------------------------------------------------------
	local ancestry = gg.onkeyword {
		name="class ancestors",
		"extends", gg.list{ _M.expr, separators="," }
	}

	local memberParser = gg.sequence {
		name="in-class method definition",
		_M.local_stat_parser,
		builder = 'Member',
	}

	local staticMemberParser = gg.sequence {
		name="in-class method definition",
		"static", _M.local_stat_parser,
		builder = 'StaticMember',
	}

	local classBody = gg.sequence {
		name = "class body",
		ancestry,
		gg.list {
			gg.multisequence { memberParser, staticMemberParser },
			terminators="end"
		},
		"end",
		builder = classBuilder
	}

	--------------------------------------------------------------------------------
	-- Pluging the parsers in the syntax
	--------------------------------------------------------------------------------
	M.lexer:add { "class", "extends", "static" }

	M.stat:add {
		name = "class declaration",
		"class", _M.id, classBody,
		builder = |x| {
			-- Class -> Local
			x[2][1],
			-- Id, Class -> Call
			`Set{ {x[1]}, {x[2][2] }}
		}
	}

	M.local_stat_parser:add {
		name = "class declaration",
		"class", _M.id, classBody,
		builder = |x| {
			`Local{ {x[1]} },
			-- Class -> Local
			x[2][1],
			-- Id, Class -> Call
			`Set{ {x[1]}, {x[2][2] }}
		}
	}
end

-------------------------------------------------------------------------------
-- Copyright (c) 2006-2013 Fabien Fleutot and others.
--
-- All rights reserved.
--
-- This program and the accompanying materials are made available
-- under the terms of the Eclipse Public License v1.0 which
-- accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- This program and the accompanying materials are also made available
-- under the terms of the MIT public license which accompanies this
-- distribution, and is available at http://www.lua.org/license.html
--
-- Contributors:
--	 Fabien Fleutot - API and implementation
--
-------------------------------------------------------------------------------
--
-- This extension implements list comprehensions, similar to Haskell and
-- Python syntax, to easily describe lists.
--
-- * x[a ... b] is the list { x[a], x[a+1], ..., x[b] }
-- * { f()..., b } contains all the elements returned by f(), then b
--	(allows to expand list fields other than the last one)
-- * list comprehensions a la python, with "for" and "if" suffixes:
--	{i+10*j for i=1,3 for j=1,3 if i~=j} is { 21, 31, 12, 32, 13, 23 }
--
-------------------------------------------------------------------------------

-{ extension ("switch", ...) }

local gg  = require 'metalua.compiler.grammar.generator'

local function dots_list_suffix_builder (x) return `DotsSuffix{ x } end

local function for_list_suffix_builder (list_element, suffix)
	local new_header = suffix[1]
	switch list_element do
		case `Comp{ _, acc } then table.insert (acc, new_header); return list_element
		case  _ then return `Comp{ list_element, { new_header } }
	end
end

local function if_list_suffix_builder (list_element, suffix)
	local new_header = `If{ suffix[1] }
	switch list_element do
		case `Comp{ _, acc } then table.insert (acc, new_header); return list_element
		case  _ then return `Comp{ list_element, { new_header } }
	end
end

--- Builds a statement from a table element, which adds this element to
-- a table `t`, potentially thanks to an alias `tinsert` to
-- `table.insert`.
-- @param core the part around which the loops are built.
--	either `DotsSuffix{expr}, `Pair{ expr } or a plain expression
-- @param list comprehension suffixes, in the order in which they appear
--	either `Forin{ ... } or `Fornum{ ...} or `If{ ... }. In each case,
--	it misses a last child node as its body.
-- @param t a variable containing the table to fill
-- @param tinsert a variable containing `table.insert`.
--
-- @return fill a statement which fills empty table `t` with the denoted element
local function comp_list_builder(core, list, t, tinsert)
	local filler
	-- 1 - Build the loop's core: if it has suffix "...", every elements of the
	-- multi-return must be inserted, hence the extra [for] loop.
	switch core do
		case `DotsSuffix{ element } then
			local x = gg.gensym()
			filler = +{stat: for _, -{x} in pairs{ -{element} } do (-{tinsert})(-{t}, -{x}) end }
		case `Pair{ key, value } then
			--filler = +{ -{t}[-{key}] = -{value} }
			filler = `Set{ { `Index{ t, key } }, { value } }
		case _ then filler = +{ (-{tinsert})(-{t}, -{core}) }
	end

	-- 2 - Stack the `if` and `for` control structures, from outside to inside.
	--	 This is done in a destructive way for the elements of [list].
	for i = #list, 1, -1 do
		table.insert (list[i], {filler})
		filler = list[i]
	end

	return filler
end

local function table_content_builder (list)
	local special = false -- Does the table need a special builder?
	for _, element in ipairs(list) do
		local etag = element.tag
		if etag=='Comp' or etag=='DotsSuffix' then special=true; break end
	end
	if not special then list.tag='Table'; return list end

	local t, tinsert = gg.gensym 'table', gg.gensym 'table_insert'
	local filler_block = { +{stat: local -{t}, -{tinsert} = { }, table.insert } }
	for _, element in ipairs(list) do
		local filler
		switch element do
			case `Comp{ core, comp } then filler = comp_list_builder(core, comp, t, tinsert)
			case _ then filler = comp_list_builder(element, { }, t, tinsert)
		end
		table.insert(filler_block, filler)
	end
	return `Stat{ filler_block, t }
end

-- Improved "[...]" index operator:
--  * support for multi-indexes ("foo[bar, gnat]")
--  * support for ranges ("foo[bar ... gnat]")
return function(M)
	local _M = gg.future(M)

	-- support for "for" / "if" comprehension suffixes in literal tables
	local original_table_element = M.table.element
	M.table.element = gg.expr{ name="table cell",
		primary = original_table_element,
		suffix  = { name="table cell suffix",
			{ "...",                builder = dots_list_suffix_builder },
			{ "for", _M.for_header, builder = for_list_suffix_builder  },
			{ "if",  _M.expr,       builder = if_list_suffix_builder   }
		}
	}
	M.table.content.builder = table_content_builder
end

--- Adds an 'export' command to export variables
-- `export a = "HELLO"` results in `local a = "HELLO", return {a  = a}`
-- `export function a() end` results in local function a() end return {a = a}`

-{ extension ("match", ...) }
-{ extension ("class", ...) }

local gg = require 'metalua.compiler.grammar.generator'
local Walker = require 'metalua.treequery.walker'

local class ExportWalker extends Walker
	returns = {}

	function traverseStatement(node, parent, ...)
		self.super.traverseStatement(self, node, parent, ...)

		if node.export then
			if parent and parent.tag and parent.tag ~= "Function" then
				self:error("Cannot export from non-function", node)
			else
				local returns = self.returns[#self.returns]
				for _, e in ipairs(node.export) do
					table.insert(returns, `Pair { `String { e[1]}, e})
				end
			end
		end
	end

	function traverseBlock(node, parent, ...)
		local returns = `Table {}
		if not parent or parent.tag == "Function" then
			table.insert(self.returns, returns)
		end

		self.super.traverseBlock(self, node, parent, ...)
		if not parent or parent.tag == "Function" then
			self.returns[#self.returns] = nil

			if #returns > 0 then
				match node[#node] with
				| `Return { ... } -> self:error("Cannot return as this method exports", node[#node])
				| _ ->
				end

				local ret = `Return { returns }
				self.super.visit(self, ret, node, parent, ...)
				table.insert(node, ret)
			end
		end
	end
end

return function(mlp)
	mlp.chunk.transformers:add(|x| ExportWalker():guess(x))

	-- Pluging the parsers in the syntax
	mlp.lexer:add { "export" }

	mlp.stat:add {
		name = "export",
		"export", mlp.local_stat_parser,
		builder = function(x)
			local export = {}
			match x[1] with
			| `Local{ lhs, rhs } ->
				for i = #lhs, 1, -1 do
					if lhs[i] ~= nil then
						table.insert (export, lhs[i])
					end
					if rhs[i] == nil then
						table.remove(lhs, i)
						table.remove(rhs, i)
					end
				end
			| `Localrec { lhs, rhs } ->
				for i = 1, #lhs do
					if lhs[i] ~= nil then
						table.insert (export, lhs[i])
					end
				end
			end

			if #export > 0 then x[1].export = export end

			return x[1]
		end
	}
end
